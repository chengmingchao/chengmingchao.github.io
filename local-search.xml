<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java中线程池的理解</title>
    <link href="/2023/04/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/04/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、线程池的优点"><a href="#1、线程池的优点" class="headerlink" title="1、线程池的优点"></a>1、线程池的优点</h3><h4 id="a-降低系统资源的消耗：减少线程的创建和销毁"><a href="#a-降低系统资源的消耗：减少线程的创建和销毁" class="headerlink" title="a. 降低系统资源的消耗：减少线程的创建和销毁"></a>a. 降低系统资源的消耗：减少线程的创建和销毁</h4><h4 id="b-提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程"><a href="#b-提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程" class="headerlink" title="b. 提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程"></a>b. 提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程</h4><h4 id="c-方便线程的管理：可以控制最大并发数"><a href="#c-方便线程的管理：可以控制最大并发数" class="headerlink" title="c. 方便线程的管理：可以控制最大并发数"></a>c. 方便线程的管理：可以控制最大并发数</h4><h3 id="2、JDK提供的创建线程池的方式"><a href="#2、JDK提供的创建线程池的方式" class="headerlink" title="2、JDK提供的创建线程池的方式"></a>2、JDK提供的创建线程池的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Executors.newSingleThreadPool();">Executors.newFixedThreadPool(3);<br>Executors.newCachedThreadPool();<br>Executors.newScheduledThreadPool(3);<br></code></pre></td></tr></table></figure><p>但是不建议这样创建线程池，alibaba开发手册中也指出这几种创建方式可能会导致OOM<br><img src="/java-threadPool-alibaba.png"></p><h3 id="3、自定义创建线程-7大参数"><a href="#3、自定义创建线程-7大参数" class="headerlink" title="3、自定义创建线程-7大参数"></a>3、自定义创建线程-7大参数</h3><p>通过阅读源码可知，jdk提供创建线程池的方式都是通过ThreadPoolExecutor来创建的，查看其构造方法如下</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<br>   <span class="hljs-keyword">int</span> corePoolSize,<br>       <span class="hljs-keyword">int</span> maximumPoolSize,<br>       <span class="hljs-keyword">long</span> keepAliveTime,<br>       TimeUnit unit,<br>       BlockingQueue&lt;Runnable&gt; workQueue,<br>       ThreadFactory threadFactory,<br>       RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure><h4 id="corePoolSize-始终保留在线程池中的线程数，即使是空闲"><a href="#corePoolSize-始终保留在线程池中的线程数，即使是空闲" class="headerlink" title="corePoolSize: 始终保留在线程池中的线程数，即使是空闲"></a>corePoolSize: 始终保留在线程池中的线程数，即使是空闲</h4><h4 id="maximumPoolSize：线程池中允许的最大线程数"><a href="#maximumPoolSize：线程池中允许的最大线程数" class="headerlink" title="maximumPoolSize：线程池中允许的最大线程数"></a>maximumPoolSize：线程池中允许的最大线程数</h4><h4 id="keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间"><a href="#keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间" class="headerlink" title="keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间"></a>keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间</h4><h4 id="unit：keepAliveTime的单位"><a href="#unit：keepAliveTime的单位" class="headerlink" title="unit：keepAliveTime的单位"></a>unit：keepAliveTime的单位</h4><h4 id="workQueue：保留任务的阻塞队列"><a href="#workQueue：保留任务的阻塞队列" class="headerlink" title="workQueue：保留任务的阻塞队列"></a>workQueue：保留任务的阻塞队列</h4><h4 id="threadFactory：用于创建新线程"><a href="#threadFactory：用于创建新线程" class="headerlink" title="threadFactory：用于创建新线程"></a>threadFactory：用于创建新线程</h4><h4 id="handler：拒绝策略"><a href="#handler：拒绝策略" class="headerlink" title="handler：拒绝策略"></a>handler：拒绝策略</h4><h3 id="4、线程池工作流程"><a href="#4、线程池工作流程" class="headerlink" title="4、线程池工作流程"></a>4、线程池工作流程</h3><p><img src="/java-threadPool-work.png"></p><h3 id="5、4大拒绝策略"><a href="#5、4大拒绝策略" class="headerlink" title="5、4大拒绝策略"></a>5、4大拒绝策略</h3><p>通过查看源码可知，RejectedExecutionHandler有如下四种实现类，即四种拒绝策略。</p><h4 id="1-AbortPolicy：-–-当任务添加到线程池中被拒绝时，它将抛出-RejectedExecutionException-异常。"><a href="#1-AbortPolicy：-–-当任务添加到线程池中被拒绝时，它将抛出-RejectedExecutionException-异常。" class="headerlink" title="1.AbortPolicy： – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。"></a>1.AbortPolicy： – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</h4><h4 id="2-CallerRunsPolicy-–-当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。"><a href="#2-CallerRunsPolicy-–-当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。" class="headerlink" title="2.CallerRunsPolicy: – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。"></a>2.CallerRunsPolicy: – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。</h4><h4 id="3-DiscardPolicy：–-当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。"><a href="#3-DiscardPolicy：–-当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。" class="headerlink" title="3.DiscardPolicy：– 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。"></a>3.DiscardPolicy：– 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。</h4><h4 id="4-DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。"><a href="#4-DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。" class="headerlink" title="4.DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。"></a>4.DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
