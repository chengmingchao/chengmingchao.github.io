<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>支付服务实践上篇-支付流程说明</title>
    <link href="/2023/04/14/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/04/14/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="聊一聊对接支付服务的一些流程"><a href="#聊一聊对接支付服务的一些流程" class="headerlink" title="聊一聊对接支付服务的一些流程"></a>聊一聊对接支付服务的一些流程</h3><h4 id="1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。"><a href="#1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。" class="headerlink" title="1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。"></a>1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。</h4><h4 id="2、先看一下对接小程序支付的一个支付及支付结果通知的流程图"><a href="#2、先看一下对接小程序支付的一个支付及支付结果通知的流程图" class="headerlink" title="2、先看一下对接小程序支付的一个支付及支付结果通知的流程图"></a>2、先看一下对接小程序支付的一个支付及支付结果通知的流程图</h4><p>以下是微信小程序支付流程图：<br><img src="/img/practice-payByWeixin.jpg"></p><h4 id="解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。"><a href="#解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。" class="headerlink" title="解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。"></a>解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。</h4><h4 id="3、另外也是支持扫码支付，以下是扫码支付的流程"><a href="#3、另外也是支持扫码支付，以下是扫码支付的流程" class="headerlink" title="3、另外也是支持扫码支付，以下是扫码支付的流程"></a>3、另外也是支持扫码支付，以下是扫码支付的流程</h4><p><img src="/img/practice-payByScan.jpg"></p><h4 id="解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付扫码支付。"><a href="#解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付扫码支付。" class="headerlink" title="解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付扫码支付。"></a>解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付扫码支付。</h4><p>下篇介绍退款流程，未完待续……</p>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中线程池的理解</title>
    <link href="/2023/04/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/04/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、线程池的优点"><a href="#1、线程池的优点" class="headerlink" title="1、线程池的优点"></a>1、线程池的优点</h3><h4 id="a-降低系统资源的消耗：减少线程的创建和销毁"><a href="#a-降低系统资源的消耗：减少线程的创建和销毁" class="headerlink" title="a. 降低系统资源的消耗：减少线程的创建和销毁"></a>a. 降低系统资源的消耗：减少线程的创建和销毁</h4><h4 id="b-提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程"><a href="#b-提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程" class="headerlink" title="b. 提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程"></a>b. 提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程</h4><h4 id="c-方便线程的管理：可以控制最大并发数"><a href="#c-方便线程的管理：可以控制最大并发数" class="headerlink" title="c. 方便线程的管理：可以控制最大并发数"></a>c. 方便线程的管理：可以控制最大并发数</h4><h3 id="2、JDK提供的创建线程池的方式"><a href="#2、JDK提供的创建线程池的方式" class="headerlink" title="2、JDK提供的创建线程池的方式"></a>2、JDK提供的创建线程池的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Executors.newSingleThreadPool();">Executors.newFixedThreadPool(3);<br>Executors.newCachedThreadPool();<br>Executors.newScheduledThreadPool(3);<br></code></pre></td></tr></table></figure><p>但是不建议这样创建线程池，alibaba开发手册中也指出这几种创建方式可能会导致OOM<br><img src="/img/java-threadPool-alibaba.png"></p><h3 id="3、自定义创建线程-7大参数"><a href="#3、自定义创建线程-7大参数" class="headerlink" title="3、自定义创建线程-7大参数"></a>3、自定义创建线程-7大参数</h3><p>通过阅读源码可知，jdk提供创建线程池的方式都是通过ThreadPoolExecutor来创建的，查看其构造方法如下</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<br>   <span class="hljs-keyword">int</span> corePoolSize,<br>       <span class="hljs-keyword">int</span> maximumPoolSize,<br>       <span class="hljs-keyword">long</span> keepAliveTime,<br>       TimeUnit unit,<br>       BlockingQueue&lt;Runnable&gt; workQueue,<br>       ThreadFactory threadFactory,<br>       RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure><h4 id="corePoolSize-始终保留在线程池中的线程数，即使是空闲"><a href="#corePoolSize-始终保留在线程池中的线程数，即使是空闲" class="headerlink" title="corePoolSize: 始终保留在线程池中的线程数，即使是空闲"></a>corePoolSize: 始终保留在线程池中的线程数，即使是空闲</h4><h4 id="maximumPoolSize：线程池中允许的最大线程数"><a href="#maximumPoolSize：线程池中允许的最大线程数" class="headerlink" title="maximumPoolSize：线程池中允许的最大线程数"></a>maximumPoolSize：线程池中允许的最大线程数</h4><h4 id="keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间"><a href="#keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间" class="headerlink" title="keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间"></a>keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间</h4><h4 id="unit：keepAliveTime的单位"><a href="#unit：keepAliveTime的单位" class="headerlink" title="unit：keepAliveTime的单位"></a>unit：keepAliveTime的单位</h4><h4 id="workQueue：保留任务的阻塞队列"><a href="#workQueue：保留任务的阻塞队列" class="headerlink" title="workQueue：保留任务的阻塞队列"></a>workQueue：保留任务的阻塞队列</h4><h4 id="threadFactory：用于创建新线程"><a href="#threadFactory：用于创建新线程" class="headerlink" title="threadFactory：用于创建新线程"></a>threadFactory：用于创建新线程</h4><h4 id="handler：拒绝策略"><a href="#handler：拒绝策略" class="headerlink" title="handler：拒绝策略"></a>handler：拒绝策略</h4><h3 id="4、线程池工作流程"><a href="#4、线程池工作流程" class="headerlink" title="4、线程池工作流程"></a>4、线程池工作流程</h3><p><img src="/img/java-threadPool-work.png"></p><h3 id="5、4大拒绝策略"><a href="#5、4大拒绝策略" class="headerlink" title="5、4大拒绝策略"></a>5、4大拒绝策略</h3><p>通过查看源码可知，RejectedExecutionHandler有如下四种实现类，即四种拒绝策略。</p><h4 id="1-AbortPolicy：-–-当任务添加到线程池中被拒绝时，它将抛出-RejectedExecutionException-异常。"><a href="#1-AbortPolicy：-–-当任务添加到线程池中被拒绝时，它将抛出-RejectedExecutionException-异常。" class="headerlink" title="1.AbortPolicy： – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。"></a>1.AbortPolicy： – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</h4><h4 id="2-CallerRunsPolicy-–-当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。"><a href="#2-CallerRunsPolicy-–-当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。" class="headerlink" title="2.CallerRunsPolicy: – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。"></a>2.CallerRunsPolicy: – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。</h4><h4 id="3-DiscardPolicy：–-当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。"><a href="#3-DiscardPolicy：–-当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。" class="headerlink" title="3.DiscardPolicy：– 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。"></a>3.DiscardPolicy：– 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。</h4><h4 id="4-DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。"><a href="#4-DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。" class="headerlink" title="4.DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。"></a>4.DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
