<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>生产遇到的事务问题</title>
    <link href="/2023/06/14/%E7%94%9F%E4%BA%A7%E9%81%87%E5%88%B0%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/14/%E7%94%9F%E4%BA%A7%E9%81%87%E5%88%B0%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="记录在大促时生产环境遇到关于事务问题"><a href="#记录在大促时生产环境遇到关于事务问题" class="headerlink" title="记录在大促时生产环境遇到关于事务问题"></a>记录在大促时生产环境遇到关于事务问题</h3><h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><h4 id="中午吃完饭，突然企业微信收到很多程序异常告警，CannotAcquireLockException……Lock-wait-timeout-exceeded……此时的我不淡定了，正值大促期间，要是出现问题那就是大问题！赶紧分析问题，定位问题发生在哪儿，即使止损。"><a href="#中午吃完饭，突然企业微信收到很多程序异常告警，CannotAcquireLockException……Lock-wait-timeout-exceeded……此时的我不淡定了，正值大促期间，要是出现问题那就是大问题！赶紧分析问题，定位问题发生在哪儿，即使止损。" class="headerlink" title="中午吃完饭，突然企业微信收到很多程序异常告警，CannotAcquireLockException……Lock wait timeout exceeded……此时的我不淡定了，正值大促期间，要是出现问题那就是大问题！赶紧分析问题，定位问题发生在哪儿，即使止损。"></a>中午吃完饭，突然企业微信收到很多程序异常告警，CannotAcquireLockException……Lock wait timeout exceeded……此时的我不淡定了，正值大促期间，要是出现问题那就是大问题！赶紧分析问题，定位问题发生在哪儿，即使止损。</h4><h3 id="2、分析"><a href="#2、分析" class="headerlink" title="2、分析"></a>2、分析</h3><h4 id="首先看到sql是更新一张表，获取锁超时，立马找运维查看目前所有的事务进程，看到很多的根据id更新这张表的sql在执行，但是想一想，根据id更新应该很快才对；通过这个更新sql找到对应的业务代码和数据情况，发现很多数据不该下发到下游的全部下发了，这个是奇怪的点，这些数据应该都是被hold在系统中才对，立马询问了对应的运营，根据运营的描述，他是点了全量下发，然后觉得点错了，立马又点了批量下发，但是操作日志上并没有看到全量下发的操作记录，但是种种迹象表明，程序肯定是执行了全部下发的指令；在接口日志里面有看到有大量重复的单号记录下来，而这个记录是发到消息队列的记录，然后又立马查看了线上mq监控，发现消息堆积一直在增长，达到了50多万，还是持续增长，排查到代码往mq发送消息方法外面有while（true），第一感觉可能是死循环了，但是也有break的判断条件，查看服务器监控，果然cpu已经达到80-了，那肯定是死循环了，但还是比较疑惑，但是管不了这么多，首先立马让运维重启了web服务，后来发现群里不再报异常，mq堆积在减少，说明没有新的消息产生，消费者在消费了，慢慢回归正常了，到这里分析下来大致定位到发生问题的服务，并重启，解决了问题。"><a href="#首先看到sql是更新一张表，获取锁超时，立马找运维查看目前所有的事务进程，看到很多的根据id更新这张表的sql在执行，但是想一想，根据id更新应该很快才对；通过这个更新sql找到对应的业务代码和数据情况，发现很多数据不该下发到下游的全部下发了，这个是奇怪的点，这些数据应该都是被hold在系统中才对，立马询问了对应的运营，根据运营的描述，他是点了全量下发，然后觉得点错了，立马又点了批量下发，但是操作日志上并没有看到全量下发的操作记录，但是种种迹象表明，程序肯定是执行了全部下发的指令；在接口日志里面有看到有大量重复的单号记录下来，而这个记录是发到消息队列的记录，然后又立马查看了线上mq监控，发现消息堆积一直在增长，达到了50多万，还是持续增长，排查到代码往mq发送消息方法外面有while（true），第一感觉可能是死循环了，但是也有break的判断条件，查看服务器监控，果然cpu已经达到80-了，那肯定是死循环了，但还是比较疑惑，但是管不了这么多，首先立马让运维重启了web服务，后来发现群里不再报异常，mq堆积在减少，说明没有新的消息产生，消费者在消费了，慢慢回归正常了，到这里分析下来大致定位到发生问题的服务，并重启，解决了问题。" class="headerlink" title="首先看到sql是更新一张表，获取锁超时，立马找运维查看目前所有的事务进程，看到很多的根据id更新这张表的sql在执行，但是想一想，根据id更新应该很快才对；通过这个更新sql找到对应的业务代码和数据情况，发现很多数据不该下发到下游的全部下发了，这个是奇怪的点，这些数据应该都是被hold在系统中才对，立马询问了对应的运营，根据运营的描述，他是点了全量下发，然后觉得点错了，立马又点了批量下发，但是操作日志上并没有看到全量下发的操作记录，但是种种迹象表明，程序肯定是执行了全部下发的指令；在接口日志里面有看到有大量重复的单号记录下来，而这个记录是发到消息队列的记录，然后又立马查看了线上mq监控，发现消息堆积一直在增长，达到了50多万，还是持续增长，排查到代码往mq发送消息方法外面有while（true），第一感觉可能是死循环了，但是也有break的判断条件，查看服务器监控，果然cpu已经达到80%了，那肯定是死循环了，但还是比较疑惑，但是管不了这么多，首先立马让运维重启了web服务，后来发现群里不再报异常，mq堆积在减少，说明没有新的消息产生，消费者在消费了，慢慢回归正常了，到这里分析下来大致定位到发生问题的服务，并重启，解决了问题。"></a>首先看到sql是更新一张表，获取锁超时，立马找运维查看目前所有的事务进程，看到很多的根据id更新这张表的sql在执行，但是想一想，根据id更新应该很快才对；通过这个更新sql找到对应的业务代码和数据情况，发现很多数据不该下发到下游的全部下发了，这个是奇怪的点，这些数据应该都是被hold在系统中才对，立马询问了对应的运营，根据运营的描述，他是点了全量下发，然后觉得点错了，立马又点了批量下发，但是操作日志上并没有看到全量下发的操作记录，但是种种迹象表明，程序肯定是执行了全部下发的指令；在接口日志里面有看到有大量重复的单号记录下来，而这个记录是发到消息队列的记录，然后又立马查看了线上mq监控，发现消息堆积一直在增长，达到了50多万，还是持续增长，排查到代码往mq发送消息方法外面有while（true），第一感觉可能是死循环了，但是也有break的判断条件，查看服务器监控，果然cpu已经达到80%了，那肯定是死循环了，但还是比较疑惑，但是管不了这么多，首先立马让运维重启了web服务，后来发现群里不再报异常，mq堆积在减少，说明没有新的消息产生，消费者在消费了，慢慢回归正常了，到这里分析下来大致定位到发生问题的服务，并重启，解决了问题。</h4><h4 id="遗留问题点：①、为何会获取锁超时；②、为什么会死循环；③、为何点了全量下发，但是系统没有操作记录？"><a href="#遗留问题点：①、为何会获取锁超时；②、为什么会死循环；③、为何点了全量下发，但是系统没有操作记录？" class="headerlink" title="遗留问题点：①、为何会获取锁超时；②、为什么会死循环；③、为何点了全量下发，但是系统没有操作记录？"></a>遗留问题点：①、为何会获取锁超时；②、为什么会死循环；③、为何点了全量下发，但是系统没有操作记录？</h4><h3 id="3、定位具体问题"><a href="#3、定位具体问题" class="headerlink" title="3、定位具体问题"></a>3、定位具体问题</h3><h4 id="下面是发生问题的伪代码："><a href="#下面是发生问题的伪代码：" class="headerlink" title="下面是发生问题的伪代码："></a>下面是发生问题的伪代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        List&lt;T&gt; list =  repositoryA.selectList();<br>        <span class="hljs-keyword">if</span> (list.isEmpty()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(T t: list) &#123;<br>            repositoryB.updateById(order);<br>            sendMessage(order);<br>            repositoryA.deleteById(t);<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-为何会发生获取锁超时呢？"><a href="#3-1-为何会发生获取锁超时呢？" class="headerlink" title="3.1 为何会发生获取锁超时呢？"></a>3.1 为何会发生获取锁超时呢？</h4><h4 id="通过运维同事的帮忙，发现的是大量根据id更新表的语句在执行，告警的也是同样的sql，结合之前的分析定位到了一个业务方法，发现在这个方法中，在while-true-中，首先是批量查询了表A的数据，如果查询为空就跳出循环，然后遍历数据，在这个循环中首先是更新表B的数据，然后发送消息，最后是删除表A的数据。看到这儿“repositoryB-updateById-order-”，应该就是对应正在执行的sql，这个方法外面是加了事务的，说明这个外面的事务在执行，那报错的sql语句肯定就是“sendMessage-order-”发生的了，果然，消费者也是执行的“-repositoryB-updateById-order-”，由于执行更新的是同一条记录，外面的事务一直没有提交，也就没有释放锁，消费者再来更新一直拿不到锁，所以就报了获取锁超时，这个问题罪魁祸首还是死循环导致的。"><a href="#通过运维同事的帮忙，发现的是大量根据id更新表的语句在执行，告警的也是同样的sql，结合之前的分析定位到了一个业务方法，发现在这个方法中，在while-true-中，首先是批量查询了表A的数据，如果查询为空就跳出循环，然后遍历数据，在这个循环中首先是更新表B的数据，然后发送消息，最后是删除表A的数据。看到这儿“repositoryB-updateById-order-”，应该就是对应正在执行的sql，这个方法外面是加了事务的，说明这个外面的事务在执行，那报错的sql语句肯定就是“sendMessage-order-”发生的了，果然，消费者也是执行的“-repositoryB-updateById-order-”，由于执行更新的是同一条记录，外面的事务一直没有提交，也就没有释放锁，消费者再来更新一直拿不到锁，所以就报了获取锁超时，这个问题罪魁祸首还是死循环导致的。" class="headerlink" title="通过运维同事的帮忙，发现的是大量根据id更新表的语句在执行，告警的也是同样的sql，结合之前的分析定位到了一个业务方法，发现在这个方法中，在while(true)中，首先是批量查询了表A的数据，如果查询为空就跳出循环，然后遍历数据，在这个循环中首先是更新表B的数据，然后发送消息，最后是删除表A的数据。看到这儿“repositoryB.updateById(order)”，应该就是对应正在执行的sql，这个方法外面是加了事务的，说明这个外面的事务在执行，那报错的sql语句肯定就是“sendMessage(order);”发生的了，果然，消费者也是执行的“ repositoryB.updateById(order)”，由于执行更新的是同一条记录，外面的事务一直没有提交，也就没有释放锁，消费者再来更新一直拿不到锁，所以就报了获取锁超时，这个问题罪魁祸首还是死循环导致的。"></a>通过运维同事的帮忙，发现的是大量根据id更新表的语句在执行，告警的也是同样的sql，结合之前的分析定位到了一个业务方法，发现在这个方法中，在while(true)中，首先是批量查询了表A的数据，如果查询为空就跳出循环，然后遍历数据，在这个循环中首先是更新表B的数据，然后发送消息，最后是删除表A的数据。看到这儿“repositoryB.updateById(order)”，应该就是对应正在执行的sql，这个方法外面是加了事务的，说明这个外面的事务在执行，那报错的sql语句肯定就是“sendMessage(order);”发生的了，果然，消费者也是执行的“ repositoryB.updateById(order)”，由于执行更新的是同一条记录，外面的事务一直没有提交，也就没有释放锁，消费者再来更新一直拿不到锁，所以就报了获取锁超时，这个问题罪魁祸首还是死循环导致的。</h4><h4 id="3-2、为什么会死循环？"><a href="#3-2、为什么会死循环？" class="headerlink" title="3.2、为什么会死循环？"></a>3.2、为什么会死循环？</h4><h4 id="这个问题困扰了我很久，当天没有想出来，请教了同事也没有发现问题出现在哪儿，看代码，“repositoryA-deleteById-t-”，每次都会删除掉一行数据，最后查询的表A肯定为空，跳出循环才对，为什么没有呢？思考的思路如下："><a href="#这个问题困扰了我很久，当天没有想出来，请教了同事也没有发现问题出现在哪儿，看代码，“repositoryA-deleteById-t-”，每次都会删除掉一行数据，最后查询的表A肯定为空，跳出循环才对，为什么没有呢？思考的思路如下：" class="headerlink" title="这个问题困扰了我很久，当天没有想出来，请教了同事也没有发现问题出现在哪儿，看代码，“repositoryA.deleteById(t)”，每次都会删除掉一行数据，最后查询的表A肯定为空，跳出循环才对，为什么没有呢？思考的思路如下："></a>这个问题困扰了我很久，当天没有想出来，请教了同事也没有发现问题出现在哪儿，看代码，“repositoryA.deleteById(t)”，每次都会删除掉一行数据，最后查询的表A肯定为空，跳出循环才对，为什么没有呢？思考的思路如下：</h4><pre><code class="hljs">a、数据库的隔离级别是RRb、查询表A是快照读c、遍历表A数据，根据id删除，再一次循环，应该查询不到数据了才对，如果是没有执行break，那必定数据没有删干净d、那就是有可能“repositoryA.deleteById(t)”这个方法有些数据没有删除到，导致下一次查询还会查到，再一次进入循环e、分析了操作日志，发现有几条相同的执行该业务逻辑的批量执行操作，操作是成功的，又发现消息中重复的数据正是这些操作的数据，每条数据大概有4W多条重复的数据，这些数据是没有执行成功的。f、想到运营同事说是先执行了全量，然后又点了批量操作，恍然大悟。g、先执行全量操作，数据比较多，在上面的伪代码里面事务会执行的时间很长，再执行批量操作，数据很少，很快被执行完了，批量操作已经把表A的部分数据删除了，但是在全量操作这个事务里面，由于是先执行，查询表A的数据是快照读还是能把这些删除的数据查询到，但是在执行“ repositoryA.deleteById(t)”方法时却删除不了数据，因为数据已经没了，导致下一次循环还是能查询到这些数据，这样就跳不出循环，一直往消息队列发送数据，导致消息堆积越来越多。</code></pre><h4 id="3-3、为何点了全量下发，但是系统没有操作记录？"><a href="#3-3、为何点了全量下发，但是系统没有操作记录？" class="headerlink" title="3.3、为何点了全量下发，但是系统没有操作记录？"></a>3.3、为何点了全量下发，但是系统没有操作记录？</h4><h4 id="上面死循环的问题找出来了，那这个问题就简单了，由于这个全量操作一直在死循环，最后是重启了服务，由于记录日志是aop，在方法执行完之后才插入到数据库，所以没有记录到。"><a href="#上面死循环的问题找出来了，那这个问题就简单了，由于这个全量操作一直在死循环，最后是重启了服务，由于记录日志是aop，在方法执行完之后才插入到数据库，所以没有记录到。" class="headerlink" title="上面死循环的问题找出来了，那这个问题就简单了，由于这个全量操作一直在死循环，最后是重启了服务，由于记录日志是aop，在方法执行完之后才插入到数据库，所以没有记录到。"></a>上面死循环的问题找出来了，那这个问题就简单了，由于这个全量操作一直在死循环，最后是重启了服务，由于记录日志是aop，在方法执行完之后才插入到数据库，所以没有记录到。</h4><h3 id="5、数据修复过程中发现另外需要继续修复的bug"><a href="#5、数据修复过程中发现另外需要继续修复的bug" class="headerlink" title="5、数据修复过程中发现另外需要继续修复的bug"></a>5、数据修复过程中发现另外需要继续修复的bug</h3><h4 id="分析到此次出现的问题主要是事务问题，MVCC问题，由于是快照读并没有读取到最新的数据。发现在做状态更改的时候有些方法还是使用的快照读，如果并发高的情况下，必然会出现问题，所以在主要的状态变更方法内，都改成了当前读。"><a href="#分析到此次出现的问题主要是事务问题，MVCC问题，由于是快照读并没有读取到最新的数据。发现在做状态更改的时候有些方法还是使用的快照读，如果并发高的情况下，必然会出现问题，所以在主要的状态变更方法内，都改成了当前读。" class="headerlink" title="分析到此次出现的问题主要是事务问题，MVCC问题，由于是快照读并没有读取到最新的数据。发现在做状态更改的时候有些方法还是使用的快照读，如果并发高的情况下，必然会出现问题，所以在主要的状态变更方法内，都改成了当前读。"></a>分析到此次出现的问题主要是事务问题，MVCC问题，由于是快照读并没有读取到最新的数据。发现在做状态更改的时候有些方法还是使用的快照读，如果并发高的情况下，必然会出现问题，所以在主要的状态变更方法内，都改成了当前读。</h4><h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><pre><code class="hljs"> a、最好不要在方法级别使用事务，推荐使用编程式事务，尽量缩小事务的范围； b、异步操作或者调用三方接口尽量不要放在事务内； c、谨慎使用while(true)，如果必要需考虑好跳出循环的条件； d、考虑并发场景下，如果需要查询最新数据的时候，使用当前读，避免快照读查询的数据不是最新的，做出的逻辑发生错误； e、分析问题的时候不能放过每一个细节，有时候出现问题很难发现，只有把每个细节串起来，才有可能定位到问题本身。</code></pre>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产环境遇到服务假死问题</title>
    <link href="/2023/05/01/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/01/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%81%87%E6%AD%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="记录服务接口请求超时假死问题"><a href="#记录服务接口请求超时假死问题" class="headerlink" title="记录服务接口请求超时假死问题"></a>记录服务接口请求超时假死问题</h3>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>退款服务实践</title>
    <link href="/2023/04/21/%E9%80%80%E6%AC%BE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8A%E7%AF%87-%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/04/21/%E9%80%80%E6%AC%BE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8A%E7%AF%87-%E9%80%80%E6%AC%BE%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h4 id="退款流程说明"><a href="#退款流程说明" class="headerlink" title="退款流程说明"></a>退款流程说明</h4><p>业务方发起退款请求，参数需要携带原支付id，退款流水号，退款金额，然后向支付平台发起退款请求，需要注意的是，退款金额不能大于原支付金额，支持部分退款。退款接口为同步接口，接口即可返回退款结果，如果返回的是中间状态，此时会创建异步任务主动查询退款结果同步到业务系统的退款状态。</p>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支付服务实践下篇-支付开发设计</title>
    <link href="/2023/04/20/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8B%E7%AF%87-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/20/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8B%E7%AF%87-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="本片文章主要是想记录下对接支付的时候的流程以及开发设计"><a href="#本片文章主要是想记录下对接支付的时候的流程以及开发设计" class="headerlink" title="本片文章主要是想记录下对接支付的时候的流程以及开发设计"></a>本片文章主要是想记录下对接支付的时候的流程以及开发设计</h3><h4 id="1、支付对接"><a href="#1、支付对接" class="headerlink" title="1、支付对接"></a>1、支付对接</h4><h4 id="在拿到接口文档的时候，不要急着对着接口的入参和出参就直接进行写代码，这些都是比较简单的。我认为比较重要的有几点："><a href="#在拿到接口文档的时候，不要急着对着接口的入参和出参就直接进行写代码，这些都是比较简单的。我认为比较重要的有几点：" class="headerlink" title="在拿到接口文档的时候，不要急着对着接口的入参和出参就直接进行写代码，这些都是比较简单的。我认为比较重要的有几点："></a>在拿到接口文档的时候，不要急着对着接口的入参和出参就直接进行写代码，这些都是比较简单的。我认为比较重要的有几点：</h4><h4 id="1）、看下支付的流程，让自己有个大概的了解；"><a href="#1）、看下支付的流程，让自己有个大概的了解；" class="headerlink" title="1）、看下支付的流程，让自己有个大概的了解；"></a>1）、看下支付的流程，让自己有个大概的了解；</h4><h4 id="2）、看下协议规则，例如：①使用什么传输方式，一般是HTTPS；②使用什么提交方式，一般是POST；③数据格式，有的是json格式，有的会提供SDK，有的是FORM格式；④字符编码，一般是UTF-8；⑤签名算法，为了安全都会约定好加密方式，比如MD5，SM2-RSA。请求时要签名，处理相应是要验签；⑥判断逻辑是什么样的，比如判断非空字段，签名正确，接口相应状态，交易状态等；"><a href="#2）、看下协议规则，例如：①使用什么传输方式，一般是HTTPS；②使用什么提交方式，一般是POST；③数据格式，有的是json格式，有的会提供SDK，有的是FORM格式；④字符编码，一般是UTF-8；⑤签名算法，为了安全都会约定好加密方式，比如MD5，SM2-RSA。请求时要签名，处理相应是要验签；⑥判断逻辑是什么样的，比如判断非空字段，签名正确，接口相应状态，交易状态等；" class="headerlink" title="2）、看下协议规则，例如：①使用什么传输方式，一般是HTTPS；②使用什么提交方式，一般是POST；③数据格式，有的是json格式，有的会提供SDK，有的是FORM格式；④字符编码，一般是UTF-8；⑤签名算法，为了安全都会约定好加密方式，比如MD5，SM2,RSA。请求时要签名，处理相应是要验签；⑥判断逻辑是什么样的，比如判断非空字段，签名正确，接口相应状态，交易状态等；"></a>2）、看下协议规则，例如：①使用什么传输方式，一般是HTTPS；②使用什么提交方式，一般是POST；③数据格式，有的是json格式，有的会提供SDK，有的是FORM格式；④字符编码，一般是UTF-8；⑤签名算法，为了安全都会约定好加密方式，比如MD5，SM2,RSA。请求时要签名，处理相应是要验签；⑥判断逻辑是什么样的，比如判断非空字段，签名正确，接口相应状态，交易状态等；</h4><h4 id="3）、看下需要的是哪些接口，有没有共同特征，比如入参，出参，判断逻辑等，可以在代码设计上做的更通用化。"><a href="#3）、看下需要的是哪些接口，有没有共同特征，比如入参，出参，判断逻辑等，可以在代码设计上做的更通用化。" class="headerlink" title="3）、看下需要的是哪些接口，有没有共同特征，比如入参，出参，判断逻辑等，可以在代码设计上做的更通用化。"></a>3）、看下需要的是哪些接口，有没有共同特征，比如入参，出参，判断逻辑等，可以在代码设计上做的更通用化。</h4><h4 id="2、背景和概述"><a href="#2、背景和概述" class="headerlink" title="2、背景和概述"></a>2、背景和概述</h4><h4 id="我要做的这个支付服务是一方面需要对接支付平台，另一方面需要对接公司其他的业务系统，也相当于一个聚合支付服务。考虑到对接的支付平台可能会变动，对接的业务系统会有多个-支付方式又有所不同，也有不同的业务类型（支付，退款，查询等等），所以在开发方案设计上，需要做到可扩展低耦合。基于这些考虑，在为业务系统提供的接口是基于业务类型来，提供了支付接口，退款接口以及查询接口（查询支付结果，退款结果等），这些是暴露出的接口，当然也包括出入参，还有一些枚举（业务方类型，支付方式等），可以提供单独的jar包方式，给到业务系统，相当于客户端，具体实现需要在服务端来做，要做的事情有以下几个，支付和退款需要生成唯一的流水号，根据不同的业务类型组装请求参数，签名，发送请求，验签，更新单据类型，通知到业务系统等等，还有一些异常处理。"><a href="#我要做的这个支付服务是一方面需要对接支付平台，另一方面需要对接公司其他的业务系统，也相当于一个聚合支付服务。考虑到对接的支付平台可能会变动，对接的业务系统会有多个-支付方式又有所不同，也有不同的业务类型（支付，退款，查询等等），所以在开发方案设计上，需要做到可扩展低耦合。基于这些考虑，在为业务系统提供的接口是基于业务类型来，提供了支付接口，退款接口以及查询接口（查询支付结果，退款结果等），这些是暴露出的接口，当然也包括出入参，还有一些枚举（业务方类型，支付方式等），可以提供单独的jar包方式，给到业务系统，相当于客户端，具体实现需要在服务端来做，要做的事情有以下几个，支付和退款需要生成唯一的流水号，根据不同的业务类型组装请求参数，签名，发送请求，验签，更新单据类型，通知到业务系统等等，还有一些异常处理。" class="headerlink" title="我要做的这个支付服务是一方面需要对接支付平台，另一方面需要对接公司其他的业务系统，也相当于一个聚合支付服务。考虑到对接的支付平台可能会变动，对接的业务系统会有多个,支付方式又有所不同，也有不同的业务类型（支付，退款，查询等等），所以在开发方案设计上，需要做到可扩展低耦合。基于这些考虑，在为业务系统提供的接口是基于业务类型来，提供了支付接口，退款接口以及查询接口（查询支付结果，退款结果等），这些是暴露出的接口，当然也包括出入参，还有一些枚举（业务方类型，支付方式等），可以提供单独的jar包方式，给到业务系统，相当于客户端，具体实现需要在服务端来做，要做的事情有以下几个，支付和退款需要生成唯一的流水号，根据不同的业务类型组装请求参数，签名，发送请求，验签，更新单据类型，通知到业务系统等等，还有一些异常处理。"></a>我要做的这个支付服务是一方面需要对接支付平台，另一方面需要对接公司其他的业务系统，也相当于一个聚合支付服务。考虑到对接的支付平台可能会变动，对接的业务系统会有多个,支付方式又有所不同，也有不同的业务类型（支付，退款，查询等等），所以在开发方案设计上，需要做到可扩展低耦合。基于这些考虑，在为业务系统提供的接口是基于业务类型来，提供了支付接口，退款接口以及查询接口（查询支付结果，退款结果等），这些是暴露出的接口，当然也包括出入参，还有一些枚举（业务方类型，支付方式等），可以提供单独的jar包方式，给到业务系统，相当于客户端，具体实现需要在服务端来做，要做的事情有以下几个，支付和退款需要生成唯一的流水号，根据不同的业务类型组装请求参数，签名，发送请求，验签，更新单据类型，通知到业务系统等等，还有一些异常处理。</h4><h4 id="3、支付流程图"><a href="#3、支付流程图" class="headerlink" title="3、支付流程图"></a>3、支付流程图</h4><p><img src="/%5Cimg%5Cpay%5Cpay_process.jpg"></p><h4 id="4、代码设计"><a href="#4、代码设计" class="headerlink" title="4、代码设计"></a>4、代码设计</h4><p>使用模板方法和策略模式设计模式，以及任务驱动思想。</p>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支付服务实践上篇-支付流程说明</title>
    <link href="/2023/04/14/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8A%E7%AF%87-%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/04/14/%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%8A%E7%AF%87-%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="聊一聊对接支付服务的一些流程"><a href="#聊一聊对接支付服务的一些流程" class="headerlink" title="聊一聊对接支付服务的一些流程"></a>聊一聊对接支付服务的一些流程</h3><h4 id="1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。"><a href="#1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。" class="headerlink" title="1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。"></a>1、项目背景是公司需要做一个微信小程序，需要一个支付和退款的功能，由于公司已经签约了另外的第三方支付平台，所以也就没有直接对接微信支付，而是通过三方支付服务间接使用微信支付。</h4><h4 id="2、先看一下对接小程序支付的一个支付及支付结果通知的流程图"><a href="#2、先看一下对接小程序支付的一个支付及支付结果通知的流程图" class="headerlink" title="2、先看一下对接小程序支付的一个支付及支付结果通知的流程图"></a>2、先看一下对接小程序支付的一个支付及支付结果通知的流程图</h4><p>以下是微信小程序支付流程图：<br><img src="/%5Cimg%5Cpay%5Cpractice-payByWeixin.jpg"></p><h4 id="解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。"><a href="#解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。" class="headerlink" title="解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。"></a>解释说明：在用户点击支付的那一刻，系统首先是生成支付流水，然后组装支付入参向三方支付服务预下单请求，这个预下单接口目的是拿到调起微信支付收银台的必要参数，将此参数给到前端，就可以在小程序弹出大家熟悉的微信支付的收银台，输入密码支付之后，微信服务会把支付结果通知给三方支付服务，三方支付服务再通过我这边提供的回掉接口通知给到我支付结果，也同时给用户反馈支付结果，至此支付流程也就结束。</h4><h4 id="3、另外也是支持扫码支付，以下是扫码支付的流程"><a href="#3、另外也是支持扫码支付，以下是扫码支付的流程" class="headerlink" title="3、另外也是支持扫码支付，以下是扫码支付的流程"></a>3、另外也是支持扫码支付，以下是扫码支付的流程</h4><p><img src="/img/pay/practice-payByScan.jpg"></p><h4 id="解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付等app扫码支付。"><a href="#解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付等app扫码支付。" class="headerlink" title="解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付等app扫码支付。"></a>解释说明：扫码支付和微信小程序支付的区别在于，在向三方支付服务预下单请求之后，会返回URL信息，将此URL转为图片base64即为支付二维码，用户可以通过微信，支付宝或者云闪付等app扫码支付。</h4><h4 id="4、扫码支付url信息过长问题"><a href="#4、扫码支付url信息过长问题" class="headerlink" title="4、扫码支付url信息过长问题"></a>4、扫码支付url信息过长问题</h4><h4 id="在做扫码支付的时候，有时候会出现扫码识别比较慢的情况，分析了原因由于url链接过长，会导致生成的二维码比较密集，扫码可能会出现扫不了的情况，因此设计了一个短链的方案。"><a href="#在做扫码支付的时候，有时候会出现扫码识别比较慢的情况，分析了原因由于url链接过长，会导致生成的二维码比较密集，扫码可能会出现扫不了的情况，因此设计了一个短链的方案。" class="headerlink" title="在做扫码支付的时候，有时候会出现扫码识别比较慢的情况，分析了原因由于url链接过长，会导致生成的二维码比较密集，扫码可能会出现扫不了的情况，因此设计了一个短链的方案。"></a>在做扫码支付的时候，有时候会出现扫码识别比较慢的情况，分析了原因由于url链接过长，会导致生成的二维码比较密集，扫码可能会出现扫不了的情况，因此设计了一个短链的方案。</h4><h4 id="短链转换，在生成扫码支付url时，将长链接存放在redis中，使用短链接作为映射，请求这个短链接会找到对应的长链接，然后重定向到长链接，从而请求到支付平台完成扫码支付。"><a href="#短链转换，在生成扫码支付url时，将长链接存放在redis中，使用短链接作为映射，请求这个短链接会找到对应的长链接，然后重定向到长链接，从而请求到支付平台完成扫码支付。" class="headerlink" title="短链转换，在生成扫码支付url时，将长链接存放在redis中，使用短链接作为映射，请求这个短链接会找到对应的长链接，然后重定向到长链接，从而请求到支付平台完成扫码支付。"></a>短链转换，在生成扫码支付url时，将长链接存放在redis中，使用短链接作为映射，请求这个短链接会找到对应的长链接，然后重定向到长链接，从而请求到支付平台完成扫码支付。</h4><p>因此在这个短链转换的请求中可以做一些事情，比如参数校验，支付校验，一个支付二维码防止重复支付等问题。</p>]]></content>
    
    
    <categories>
      
      <category>项目实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中线程池的理解</title>
    <link href="/2023/04/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/04/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、线程池的优点"><a href="#1、线程池的优点" class="headerlink" title="1、线程池的优点"></a>1、线程池的优点</h3><h4 id="a-降低系统资源的消耗：减少线程的创建和销毁"><a href="#a-降低系统资源的消耗：减少线程的创建和销毁" class="headerlink" title="a. 降低系统资源的消耗：减少线程的创建和销毁"></a>a. 降低系统资源的消耗：减少线程的创建和销毁</h4><h4 id="b-提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程"><a href="#b-提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程" class="headerlink" title="b. 提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程"></a>b. 提高响应速度：任务到来时，可以直接使用线程池中的线程执行，不用等待创建线程</h4><h4 id="c-方便线程的管理：可以控制最大并发数"><a href="#c-方便线程的管理：可以控制最大并发数" class="headerlink" title="c. 方便线程的管理：可以控制最大并发数"></a>c. 方便线程的管理：可以控制最大并发数</h4><h3 id="2、JDK提供的创建线程池的方式"><a href="#2、JDK提供的创建线程池的方式" class="headerlink" title="2、JDK提供的创建线程池的方式"></a>2、JDK提供的创建线程池的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Executors.newSingleThreadPool();">Executors.newFixedThreadPool(3);<br>Executors.newCachedThreadPool();<br>Executors.newScheduledThreadPool(3);<br></code></pre></td></tr></table></figure><p>但是不建议这样创建线程池，alibaba开发手册中也指出这几种创建方式可能会导致OOM<br><img src="/img/java-threadPool-alibaba.png"></p><h3 id="3、自定义创建线程-7大参数"><a href="#3、自定义创建线程-7大参数" class="headerlink" title="3、自定义创建线程-7大参数"></a>3、自定义创建线程-7大参数</h3><p>通过阅读源码可知，jdk提供创建线程池的方式都是通过ThreadPoolExecutor来创建的，查看其构造方法如下</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ThreadPoolExecutor(<br>   <span class="hljs-keyword">int</span> corePoolSize,<br>       <span class="hljs-keyword">int</span> maximumPoolSize,<br>       <span class="hljs-keyword">long</span> keepAliveTime,<br>       TimeUnit unit,<br>       BlockingQueue&lt;Runnable&gt; workQueue,<br>       ThreadFactory threadFactory,<br>       RejectedExecutionHandler <span class="hljs-keyword">handler</span>)<br></code></pre></td></tr></table></figure><h4 id="corePoolSize-始终保留在线程池中的线程数，即使是空闲"><a href="#corePoolSize-始终保留在线程池中的线程数，即使是空闲" class="headerlink" title="corePoolSize: 始终保留在线程池中的线程数，即使是空闲"></a>corePoolSize: 始终保留在线程池中的线程数，即使是空闲</h4><h4 id="maximumPoolSize：线程池中允许的最大线程数"><a href="#maximumPoolSize：线程池中允许的最大线程数" class="headerlink" title="maximumPoolSize：线程池中允许的最大线程数"></a>maximumPoolSize：线程池中允许的最大线程数</h4><h4 id="keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间"><a href="#keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间" class="headerlink" title="keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间"></a>keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程在终止之前等待新任务的时间</h4><h4 id="unit：keepAliveTime的单位"><a href="#unit：keepAliveTime的单位" class="headerlink" title="unit：keepAliveTime的单位"></a>unit：keepAliveTime的单位</h4><h4 id="workQueue：保留任务的阻塞队列"><a href="#workQueue：保留任务的阻塞队列" class="headerlink" title="workQueue：保留任务的阻塞队列"></a>workQueue：保留任务的阻塞队列</h4><h4 id="threadFactory：用于创建新线程"><a href="#threadFactory：用于创建新线程" class="headerlink" title="threadFactory：用于创建新线程"></a>threadFactory：用于创建新线程</h4><h4 id="handler：拒绝策略"><a href="#handler：拒绝策略" class="headerlink" title="handler：拒绝策略"></a>handler：拒绝策略</h4><h3 id="4、线程池工作流程"><a href="#4、线程池工作流程" class="headerlink" title="4、线程池工作流程"></a>4、线程池工作流程</h3><p><img src="/img/java-threadPool-work.png"></p><h3 id="5、4大拒绝策略"><a href="#5、4大拒绝策略" class="headerlink" title="5、4大拒绝策略"></a>5、4大拒绝策略</h3><p>通过查看源码可知，RejectedExecutionHandler有如下四种实现类，即四种拒绝策略。</p><h4 id="1-AbortPolicy：-–-当任务添加到线程池中被拒绝时，它将抛出-RejectedExecutionException-异常。"><a href="#1-AbortPolicy：-–-当任务添加到线程池中被拒绝时，它将抛出-RejectedExecutionException-异常。" class="headerlink" title="1.AbortPolicy： – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。"></a>1.AbortPolicy： – 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。</h4><h4 id="2-CallerRunsPolicy-–-当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。"><a href="#2-CallerRunsPolicy-–-当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。" class="headerlink" title="2.CallerRunsPolicy: – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。"></a>2.CallerRunsPolicy: – 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。</h4><h4 id="3-DiscardPolicy：–-当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。"><a href="#3-DiscardPolicy：–-当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。" class="headerlink" title="3.DiscardPolicy：– 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。"></a>3.DiscardPolicy：– 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。</h4><h4 id="4-DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。"><a href="#4-DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。" class="headerlink" title="4.DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。"></a>4.DiscardOldestPolicy：当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
